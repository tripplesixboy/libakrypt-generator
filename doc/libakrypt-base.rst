Служебные и вспомогательные функции библиотеки
==============================================

В этом разделе рассматриваются служебные
и вспомогательные функции, которые входят в состав библиотеки ``libakrypt-base``.
Большинство этих функций носят служебный характер и реализованы для исключения внешних зависимостей.

Есть ли функции для преобразования двоичных данных?
---------------------------------------------------

При тестировании и отладке криптографических алгоритмов возникает необходимость выводить
обрабатываемые данные в четовекочитаемом виде, т.е. в виде последовательности шестнадцатеричных символов.
Наиболее употребимым способом вывода областей (дампов) памяти
произвольного размера является использование следующих функций:

- функция :func:`ak_ptr_to_hexstr` предназначена для преобразования произвольной области памяти
  в строку шестнадцатеричных символов (функция возвращает указатель на стек, данные в котором могут быть
  перезаписаны при следующем вызове функции библиотеки);
- функция :func:`ak_ptr_to_hexstr_alloc` предназначена для преобразования произвольной области памяти
  в строку шестнадцатеричных символов (функция возвращает указатель на область в оперативной памяти,
  которая позднее должна быть удалена пользователем с помощью функции :func:`free`);
- функция :func:`ak_hexstr_to_ptr` предназначена для обратного преобразования строк
  шестнадцатеричных символов в двоичные данные;
- функция :func:`ak_hexstr_size` высчитывает максимальную длину в
  байтах для формируемой последовательности двоичных данных.


Простейший пример использования указанных функций приводится ниже (файл ``example-g02n01.c``).

.. literalinclude:: ../examples/faq/example-g02n01.c
 :language: c
 :linenos:

Какие ещё есть функции для работы с двоичными данными?
------------------------------------------------------

Дополнительно, в библиотеке реализован ряд вспомогательных функций для работы с областями памяти.

- функция :func:`ak_ptr_is_equal` выполняет побайтное сравнение двух областей памяти,
- функция :func:`ak_ptr_is_equal_with_log` выполняет побайтное сравнение двух областей памяти;
  в случае выявления различия данных, с помощью системы аудита выводится не только сообщение об ошибке,
  но и место, в котором находится различие;
- функция :func:`ak_ptr_fletcher32` вычисляет контрольную сумму Флетчера;
- функция :func:`ak_ptr_load_from_file` позволяет считать указанный файл в буффер
  (если выделенной под буффер памяти не достаточно, то функция выделяет область в оперативной памяти,
  данная область должна быть позднее освобождена с помощью функции :func:`free`).


Можно ли кодировать данные в base64?
------------------------------------

Основная причина использования кодировки **base64**
заключается в необходимости создания сертификатов открытых ключей в формате `pem`,
контейнеров секретных ключей, а также почтовых вложений, кодируемых при помощи алфавита
из 64-х символов:

.. code-block:: c

  /*! Используемый для кодирования алфавит, согласно RFC1113 */
  static const char base64[]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

В случае необходимости использования кодировки **base64**,
библитека предоставляет следующие функции:

- функция :func:`ak_ptr_to_base64` выполняет кодирование двоичных данных в строку символов,
- функция :func:`ak_ptr_to_base64_alloc` выполняет кодирование двоичных данных в строку символов, с обязательным
  выделение оперативной памяти под строку символов,
- функция :func:`ak_ptr_to_base64_size` вычисляет объем памяти, в которую может поместиться закодированная строка,
- функция :func:`ak_base64_to_ptr` выполняет обратное преобразование и преобразует строку символов
  в двоичную последовательность.

Пример использования указанных функций содержится в файле ``example-g02n04.c``.

.. literalinclude:: ../examples/faq/example-g02n04.c
 :language: c
 :linenos:



Есть ли функции для работы со списками?
---------------------------------------

В библиотеке реализован интерфейс для работы с двусвязными списками.
Элемент списка определяется следующей структурой.

.. code-block:: c

 /*! \brief Узел двусвязного списка. */
 typedef struct list_node {
   /*! \brief указатель на хранимые данные. */
    ak_pointer data;
   /*! \brief указатель на предыдущий узел списка. */
    ak_list_node prev;
   /*! \brief указатель на следующий узел списка. */
    ak_list_node next;
 } *ak_list_node;


Структура содержит в себе указатель ``data``, который должен использоваться
для размещения произвольных данных.
Создание узла двусвязного списа возлагается на пользователя.
Если в качестве данных выступает строка символов,
то можеь быть использована функция :func:`ak_list_node_new_string`.

Пример использования двусвязного списка приводится ниже (файл ``example-g02n02.c``)

.. literalinclude:: ../examples/faq/example-g02n02.c
 :language: c
 :linenos:

Если вам необходимо работать с двусвязными списками строк,
то для этого библиотека реализует еще одну функцию :func:`ak_list_node_new_string`.
Пример ее использования приводится далее (файл ``example-g02n03.c``).

.. literalinclude:: ../examples/faq/example-g02n03.c
 :language: c
 :linenos:


..
   Существуют ли функции для работы с файлами конфигурации?
   --------------------------------------------------------
   Как кодировать в base64?
   ------------------------------------------------------------
   Как организовать доступ к файлам?
   ------------------------------------------------------------
   Есть ли интерфейс к разделяемой памяти?
   ------------------------------------------------------------


