Выработка производных ключей
============================

Выработка производной ключевой информации является обязательной забавой при
реализации средств криптографической защиты информации, например,
при реализации протоколов выработки общего ключа, 
при проведении аутентификации пользователей средств защиты,
а также в ряде других случаев.

В библиотеке реализовано несколько различных подходов к выработки производных ключей:

- выработка ключа из пароля с помощью функции `PBKDF`, определяемой рекомендациями
  `Р 1323565.1.040-2022 <https://tc26.ru/standarts/rekomendatsii-po-standartizatsii/r-1323565-1-040-2022-informatsionnaya-tekhnologiya-kriptograficheskaya-zashchita-informatsii-parolnaya-zashchita-klyuchevoy-informatsii.html>`__:

.. math::

   K_{n} = PBKDF( \textit{password}, \textit{seed} ),

- выработка производных ключей из исходного ключа `MK`,
  индексируемых строками проивольной длины, с помощью функции `KDF_GOSTR3411_2012_256` или, коротко, `KDF256`
  (функция определяется в `Р 50.1.113-2016 <https://tc26.ru/standard/rs/%D0%A0%2050.1.113-2016.pdf>`__, раздел 4.4):

.. math::

   K_{n} = KDF256( MK, \texttt{label} ),

- выработка производных ключей из исходного ключа `MK`, индексируемых значениями натуральных чисел,
  с помощью функции `TLSTREE`
  (функция определяется в Р 1323565.1.030-2019):

.. math::

   K_{n} = TLSTREE( MK, n ), \quad n = 0, 1, \ldots 2^{64}-1,

- выработка производных ключей из исходного ключа, индексируемых значениями
  последовательно возрастающих натуральных чисел

.. math::

   K_{n+1} = KDF( K_{n} ), \quad K_0 = MK, \quad n = 0, 1, \ldots 2^{64}-1.


Остановимся на каждом из перечисленных подходов более детально.

Выработка производного ключа из пароля
--------------------------------------

Выработка производного ключа из пароля
является максимально распространенным явлением при проверке прав доступа к чему-либо.
И это не смотря на то, что пароли, как правило, не являются равномерно распределенными
и подвержены атакам перебора по заранее подготовленным словарям.

Функция PBKDF принимает на вход два значения:

 - секретный пароль, знание которого и обеспечивает наличие прав доступа,
 - затравка - случайное или псевдо-случайное значение, которое становится известным нарушителю только в момент
   аутентификации; это позволяет защититься от некоторого класса атак,
   основанных на предварительной выработке и последующем опробовании значений функции PBKDF, вычисленных для
   множества наиболее вероятных паролей.


Алгоритм PBKDF реализуется при помощи одной из следующих функций:

.. c:function:: int ak_hmac_pbkdf2_streebog512();

.. c:function:: int ak_bckey_create_key_pair_from_password();


Первая функция вырабатывает вектор длины от 32 до 64 байт, который может быть
использован пользователем по своему усмотрению.

Вторая функция вырабатывает пару ключей по 32 байта -- такая пара может использоваться в случае необходимости
одновременного шифрования и имитозащиты информации и применяется,
как правило, при доступе к ключевым контейнерам.




Функция KDF256 и проиводные ключи с метками
-------------------------------------------

.. note::
  Будет раскрыто позже.


Функция TLSTREE и проиводные ключи с номерами
---------------------------------------------

В процессе разработки протокола TLS версии 1.3 была придумана функция TLSTREE,
которая оказалась достаточно эффективной и получила, в последствии, применение в других
криптографических протоколах, например, в протоколах семейства IPSec.

Основная особенность
функции TLSTREE заключается в том, что она реализует отображение

.. math::

   K_{n} = \texttt{TLSTREE}( MK, n ), \quad n = 0, 1, \ldots 2^{64}-1.

при различных вызовах которого, последовательность выбора значений `n` не играет ни какой роли, т.е.,
можно вычислить :math:`K_{100}`, а потом :math:`K_{1}`, :math:`K_{70}`, :math:`K_{15}` и т.д.
Конечно можно не выделываться,
и вычислять производные ключи последовательно: :math:`K_{0}`, :math:`K_{1}`, :math:`K_{2}`, и т.д.
В обоих случаях, выбор остается за приложением, в котором применяется функция TLSTREE.

Воспользоваться алгоритмом TLSTREE можно при помощи одной из следующих функций:

.. c:function::  int ak_skey_derive_tlstree();

.. c:function::  int ak_skey_derive_tlstree_from_skey();

.. c:function::  ak_pointer ak_skey_new_derive_tlstree_from_skey();

Отличия между указанными функциями заключаются
в способе передачи исходной ключевой информации и возврата нового выработанного значения.

Обратим внимание, что, согласно рекомендациям Р 1323565.030-2019, условие

.. math::

   K_{n} = \texttt{TLSTREE}( MK, n ) \not= \texttt{TLSTREE}( MK, m ) = K_{m}, \quad n \not= m

в общем случае, `не обеспечивается`. Выполнение этого условия зависит от используемого
множества предопределенных в Р 2323565.030-2019 констант. При этом, само множество констант является
обязательным параметром алгоритма TLSTREE и передается в функцию при помощи переменной типа `tlstree_t`.

Библиотекой гарантируется уникальность вырабатываемых производных ключей,
только для значений `tlstree_with_libakrypt_65536` и `tlstree_with_libakrypt_4096`.
В остальных случаях, поведение функции соотвествует Р 2323565.030-2019.

Простейший пример
использования функции `ak_sket_derive_tlstree()` приводится ниже (файл ``example-g05n01.c``).

.. literalinclude:: ../examples/faq/example-g05n01.c
 :language: c
 :linenos:

Пример, в котором последовательно вычисляются производные ключи
:math:`K_{0}`, :math:`K_{1}`, :math:`\ldots`, :math:`K_{15}`, приводится далее в файле ``example-g05n02.c``.
Здесь иллюстрируется вызов функции `ak_skey_new_derive_tlstree_from_skey()`,
позволяющей выработать контекст секретного ключа, что называется, `готовый к применению`
-- в данном примере, готовый к зашифрованию и расшифрованию данных с помощью блочного шифра "Магма"
в режиме гаммирования.

.. literalinclude:: ../examples/faq/example-g05n02.c
 :language: c
 :linenos:


Для оптимизации
последовательной генерации ключей с использованием алгоритма TLSTREE
может использоваться специальный контекст и набор функций:

.. c:function::  int ak_tlstree_state_create();
.. c:function::  int ak_tlstree_state_next();
.. c:function::  ak_uint8 *ak_tlstree_state_get_key();
.. c:function::  int ak_tlstree_state_destroy();

Пример использования данных функций приводится ниже (файл ``example-g05n03.c``).

.. literalinclude:: ../examples/faq/example-g05n03.c
 :language: c
 :linenos:


Класс преобразований из Р 1323565.1.022-2018 и последовательности производных ключей
------------------------------------------------------------------------------------

В предыдущем случае необходимо помнить MK
на протяжении всего срока дейcтвия ключевой информации, который (срок) может быть весьма большим.
Потенциально, это создает возможность компрометации значения некриптографическими способами.

Для защиты от такой угрозы реализован подход,
в котором предыдущее значение уничтожается после создания следующего и тем самым сокращается срок
хранения актуальной ключевой информации.

