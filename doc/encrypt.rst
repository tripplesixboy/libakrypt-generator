Простейшие криптографические преобразования
===========================================

Шифрование данных
-----------------

Шифрование данных представляет собой процедуру преобразования
исходных данных с помощью секретного ключа.
В библиотеке ``libakrypt`` принято соглашение, по которому,
каждый ключ предназначается для одного или небольшого класса однотипных
криптографических преобразований, т.е. ключ шифрования данных нельзя использовать
для их имитозащиты или выработки электронной подписи.

Реализация подобного соглашения подразумевает,
что каждому ключу соответствует контекст, содержащий как сам ключ,
так и указатели на методы, предназначенные для его обработки.

Обычная последовательность использования ключа состоит из нескольких простых шагов:

  1. создание контекста ключа
  2. присвоение ключу секретного значения
  3. обработка данных (зашифрование, расшифрование, выработка имитовставки и т.п.)
  4. освобождение контекста ключа.

Рассмотрим перечисленные шаги более подробно на примере
алгоритмов блочного шифрования.


Для создания ключа могут быть использованы следующие функции:

 - :func:`int ak_bckey_create_magma`;
 - :func:`int ak_bckey_create_kuznechik`;
 - :func:`int ak_bckey_create_oid`.

Первым аргументом указанных функций
служит указатель контекст создаваемого секретного ключа - структуру ``struct bckey``.
Вызов функции в явном виде указывает для какого алгоритма блочного шифрования предназначается
контекст секретного ключа. В настоящее время в библиотеке реализованы
два отечественных алгоритма блочного шифрования - Магма и Кузнечик,
регламентируемые стандартом ГОСТ Р 34.12-2015.

Функция :func:`int ak_bckey_create_oid` обладает двумя арументами и
позволяет создать контекст секретного ключа с использованием идентификатора объекта (``struct oid``).


После создания ключа ему должно быть присвоено некоторое значение.
Это можно сделать с помощью следующих функций.

 - :func:`int ak_bckey_set_key`;
 - :func:`int ak_bckey_set_key_random`;
 - :func:`int ak_bckey_set_key_from_password`.

Первая функция выполняет присвоение ключу константного значения.
Вторая функция вырабатывает случайное значение ключа с использованием заданного генератора случайных чисел.
Последняя функция вырабатывает значение ключа из строки символов, являющейся,
как правило, паролем пользователя.


Для шифрования данных предназначено несколько функций,
реализующих различные режимы шифрования:

 - :func:`int ak_bckey_encrypt_cbc` - зашифрование в режиме простой замены с зацеплением;
 - :func:`int ak_bckey_decrypt_cbc` - расшифрование в режиме простой замены с зацеплением;
 - :func:`int ak_bckey_ctr` - шифрование в режиме гаммирования;
 - :func:`int ak_bckey_ofb` - шифрование в режиме гаммирования с обратной связью по выходу;
 - :func:`int ak_bckey_encrypt_cfb` - зашифрование данных в режиме гаммирования с обратной связью по шифртексту;
 - :func:`int ak_bckey_decrypt_cfb` - расшифрование данных в режиме гаммирования с обратной связью по шифртексту;
 - :func:`int ak_bckey_ctr_acpkm` - шифрование данных в режиме `CTR-ACPKM`;
 - :func:`int ak_bckey_encrypt_xts` - зашифрование данных в режиме `XTS`;
 - :func:`int ak_bckey_decrypt_xts` - расшифрование данных в режиме `XTS`.


Удаление контекста секретного ключа должно выполняться при помощи функции

 - :func:`int ak_bckey_destroy`.


Простейший пример, иллюстрирующий процесс шифрования данных,
содержащихся в оперативной памяти, приводится ниже (файл ``example-g03n01.c``).

.. literalinclude:: ../examples/faq/example-g03n01.c
 :language: c
 :linenos:

Контекст секретного ключа
сохраняет состояние пременных, используемых для реализаии режима гаммирования.
Это позволяет зашифровывать информацию не за один вызов функции,
а несколькими фрагментами, длина которых кратна длине блока алгоритма шифрования.
Такая особенность может быть востребована при обработке потоковых данных,
без необходимости их буфферезированного хранения в памяти вычислительного средства.
Пример такой обработки данных приводится в следующем примере (файл ``example-g03n02.c``).

.. literalinclude:: ../examples/faq/example-g03n02.c
 :language: c
 :linenos:


Вычисление имитовставки
-----------------------

Имитовставка - это контрольная сумма, вычисленная с использованием секретного ключа
или, другими словами, код аутентификации данных.
Использование секретного ключа
не позволяет нарушителю подделывать код аутентификации и, тем самым,
навязывать ложные данные.

Для вычисления имитовставки
могут применяться различные алгоритмы:

  -  режим ``cmac``, основанный на применении алгоритмов блочного шифрования
     (этот режим стандартизирован в ГОСТ Р 34.13-2015);
  -  режим ``hmac``, основанный на применении функций хеширования;
  -  режим ``nmac``, являющийся комбинацией нескольких алгоритмов хеширования.

Последовательность вычисления имитовставки,
как и ранее, состоит из четырех простых шагов:

  1. создание контекста ключа ,
  2. присвоение ключу секретного значения,
  3. вычисление имитовставки,
  4. освобождение контекста ключа.


1. Для использования алгоритма ``cmac`` необходимо создать
контекст секретного ключа блочного алгоритма шифрования и присвоить ему значение.
Для этого должны применяться функции, описанные выше.

Далее, для выработки имитовставки должна применяться функция:

 - :func:`int ak_bckey_cmac`.

Отметим, что длина имитовставки, вырабатываемой алгоритмом ``cmac``, совпадает с
длиной блока используемого алгоритма шифрования: 8 октетов для алгоритма Магма
и 16 октов для алгоритма Кузнечик.

Пример вычисления имитовставки приводится далее  (файл ``example-g03n03.c``).

.. literalinclude:: ../examples/faq/example-g03n03.c
 :language: c
 :linenos:

2. Для использования алгоритма ``hmac`` необходимо создать контекст
секретного ключа с помощью вызова одной из следующих функций:

 - :func:`int ak_hmac_create_streebog256`.
 - :func:`int ak_hmac_create_streebog512`.

Отличие между этими функциями заключается в использовании
базовой функции хеширования и, как следствие, длине вырабатываемой имитовставки:
32 октета для алгоритма Стрибог256 и 64 октета для функции Стрибог512.

Далее, для выработки имитовставки должна применяться функция:

 - :func:`int ak_hmac_ptr`.

Удаление контекста секретного ключа алгоритма ``hmac`` должно выполняться
с использованием функции

 - :func:`int ak_hmac_destroy`.

Пример вычисления имитовставки с помощью алгоритма ``hmac`` приводится далее  (файл ``example-g03n04.c``).

.. literalinclude:: ../examples/faq/example-g03n04.c
 :language: c
 :linenos:

..
   Хеширование и вычисление имитовставок
   =====================================

   Аутентифицированное шифрование (AEAD)
   =====================================

   Простая реализация
   ~~~~~~~~~~~~~~~~~~

   Прямое  и обратное преобразования,
   которые могут быть получены через `oid->func.direct( .. )`

