Простейшие криптографические преобразования
===========================================

Шифрование данных
-----------------

Шифрование данных представляет собой процедуру преобразования
исходных данных с помощью секретного ключа.
В библиотеке ``libakrypt`` принято соглашение, по которому,
каждый ключ предназначается для одного или небольшого класса однотипных
криптографических преобразований, т.е. ключ шифрования данных нельзя использовать
для их имитозащиты или выработки электронной подписи.

Реализация подобного соглашения подразумевает,
что каждому ключу соответствует контекст, содержащий как сам ключ,
так и указатели на методы, предназначенные для его обработки.

Обычная последовательность использования ключа состоит из нескольких простых шагов:

  1. создание контекста ключа
  2. присвоение ключу секретного значения
  3. обработка данных (зашифрование, расшифрование, выработка имитовставки и т.п.)
  4. освобождение контекста ключа.

Рассмотрим перечисленные шаги более подробно на примере
алгоритмов блочного шифрования.


Для создания ключа могут быть использованы следующие функции:

 - :func:`int ak_bckey_create_magma`;
 - :func:`int ak_bckey_create_kuznechik`;
 - :func:`int ak_bckey_create_oid`.

Первым аргументом указанных функций
служит указатель контекст создаваемого секретного ключа - структуру ``struct bckey``.
Вызов функции в явном виде указывает для какого алгоритма блочного шифрования предназначается
контекст секретного ключа. В настоящее время в библиотеке реализованы
два отечественных алгоритма блочного шифрования - Магма и Кузнечик,
регламентируемые стандартом ГОСТ Р 34.12-2015.

Функция :func:`int ak_bckey_create_oid` обладает двумя арументами и
позволяет создать контекст секретного ключа с использованием идентификатора объекта (``struct oid``).


После создания ключа ему должно быть присвоено некоторое значение.
Это можно сделать с помощью следующих функций.

 - :func:`int ak_bckey_set_key`;
 - :func:`int ak_bckey_set_key_random`;
 - :func:`int ak_bckey_set_key_from_password`.

Первая функция выполняет присвоение ключу константного значения.
Вторая функция вырабатывает случайное значение ключа с использованием заданного генератора случайных чисел.
Последняя функция вырабатывает значение ключа из строки символов, являющейся,
как правило, паролем пользователя.


Для шифрования данных предназначено несколько функций,
реализующих различные режимы шифрования:

 - :func:`int ak_bckey_encrypt_cbc` - зашифрование в режиме простой замены с зацеплением;
 - :func:`int ak_bckey_decrypt_cbc` - расшифрование в режиме простой замены с зацеплением;
 - :func:`int ak_bckey_ctr` - шифрование в режиме гаммирования;
 - :func:`int ak_bckey_ofb` - шифрование в режиме гаммирования с обратной связью по выходу;
 - :func:`int ak_bckey_encrypt_cfb` - зашифрование данных в режиме гаммирования с обратной связью по шифртексту;
 - :func:`int ak_bckey_decrypt_cfb` - расшифрование данных в режиме гаммирования с обратной связью по шифртексту;
 - :func:`int ak_bckey_ctr_acpkm` - шифрование данных в режиме `CTR-ACPKM`;
 - :func:`int ak_bckey_encrypt_xts` - зашифрование данных в режиме `XTS`;
 - :func:`int ak_bckey_decrypt_xts` - расшифрование данных в режиме `XTS`.


Удаление контекста секретного ключа должно выполняться при помощи функции

 - :func:`int ak_bckey_destroy`.


Простейший пример, иллюстрирующий процесс шифрования данных,
содержащихся в оперативной памяти, приводится ниже (файл ``example-g03n01.c``).

.. literalinclude:: ../examples/faq/example-g03n01.c
 :language: c
 :linenos:

Контекст секретного ключа
сохраняет состояние пременных, используемых для реализаии режима гаммирования.
Это позволяет зашифровывать информацию не за один вызов функции,
а несколькими фрагментами, длина которых кратна длине блока алгоритма шифрования.
Такая особенность может быть востребована при обработке потоковых данных,
без необходимости их буфферезированного хранения в памяти вычислительного средства.
Пример такой обработки данных приводится в следующем примере (файл ``example-g03n02.c``).

.. literalinclude:: ../examples/faq/example-g03n02.c
 :language: c
 :linenos:


Вычисление имитовставки
-----------------------

Имитовставка - это контрольная сумма, вычисленная с использованием секретного ключа
или, другими словами, код аутентификации данных.
Использование секретного ключа
не позволяет нарушителю подделывать код аутентификации и, тем самым,
навязывать ложные данные.

Для вычисления имитовставки
могут применяться различные алгоритмы:

  -  режим ``cmac``, основанный на применении алгоритмов блочного шифрования
     (этот режим стандартизирован в ГОСТ Р 34.13-2015);
  -  режим ``hmac``, основанный на применении функций хеширования;
  -  режим ``nmac``, являющийся комбинацией нескольких алгоритмов хеширования.

Последовательность вычисления имитовставки,
как и ранее, состоит из четырех простых шагов:

  1. создание контекста ключа ,
  2. присвоение ключу секретного значения,
  3. вычисление имитовставки,
  4. освобождение контекста ключа.


1. Для использования алгоритма ``cmac`` необходимо создать
контекст секретного ключа блочного алгоритма шифрования и присвоить ему значение.
Для этого должны применяться функции, описанные выше.

Далее, для выработки имитовставки должна применяться функция:

 - :func:`int ak_bckey_cmac`.

Отметим, что длина имитовставки, вырабатываемой алгоритмом ``cmac``, совпадает с
длиной блока используемого алгоритма шифрования: 8 октетов для алгоритма Магма
и 16 октов для алгоритма Кузнечик.

Пример вычисления имитовставки приводится далее  (файл ``example-g03n03.c``).

.. literalinclude:: ../examples/faq/example-g03n03.c
 :language: c
 :linenos:

2. Для использования алгоритма ``hmac`` необходимо создать контекст
секретного ключа с помощью вызова одной из следующих функций:

 - :func:`int ak_hmac_create_streebog256`.
 - :func:`int ak_hmac_create_streebog512`.

Отличие между этими функциями заключается в использовании
базовой функции хеширования и, как следствие, длине вырабатываемой имитовставки:
32 октета для алгоритма Стрибог256 и 64 октета для функции Стрибог512.

Далее, для выработки имитовставки должна применяться функция:

 - :func:`int ak_hmac_ptr`.

Удаление контекста секретного ключа алгоритма ``hmac`` должно выполняться
с использованием функции

 - :func:`int ak_hmac_destroy`.

Пример вычисления имитовставки с помощью алгоритма ``hmac`` приводится далее  (файл ``example-g03n04.c``).

.. literalinclude:: ../examples/faq/example-g03n04.c
 :language: c
 :linenos:


Выработка производной ключевой информации
-----------------------------------------

Выработка производный ключей является обязательной забавой при
проведении аутентификации пользователей средств защиты,
реализации криптографических схем и протоколов, а также в ряде других случаев.
В библиотеке реализовано несколько подходов:

- выработка ключа из пароля

.. math::

   K_{n} = F_1( \texttt{password} ).

- выработка производного ключа из исходного ключа `MK` с помощью последовательностей символов,

.. math::

   K_{n} = F_2( MK, \texttt{label} ).

- выработка производных ключей из исходного ключа `MK`, индексируемых значениями натуральных чисел
  в произвольном порядке,

.. math::

   K_{n} = F_3( MK, n ), \quad n = 0, 1, \ldots 2^{64}-1.

- выработка производных ключей из исходного ключа, индексируемых значениями
  последовательно возрастающих натуральных чисел

.. math::

   K_{n+1} = F_4( K_{n} ), \quad K_0 = MK, \quad n = 0, 1, \ldots 2^{64}-1.


Остановимся на каждом из перечисленных подходов более детально.

Выработка производного ключа из пароля
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Будет раскрыто позже.

Функция KDF256 и проиводные ключи с метками
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Будет раскрыто позже.

Функция TLSTREE и проиводные ключи с номерами
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В процессе разработки протокола TLS версии 1.3 была придумана функция TLSTREE,
которая оказалась достаточно эффективной и получила, в последствии, применение в других
криптографических протоколах, например, в протоколах семейства IPSec.

Основная особенность
функции TLSTREE заключается в том, что она реализует отображение

.. math::

   K_{n} = \texttt{TLSTREE}( MK, n ), \quad n = 0, 1, \ldots 2^{64}-1.

при различных вызовах которого, последовательность выбора значений `n` не играет ни какой роли, т.е.,
можно вычислить :math:`K_{100}`, а потом :math:`K_{1}`, :math:`K_{70}`, :math:`K_{15}` и т.д.
Конечно можно не выделываться,
и вычислять производные ключи последовательно: :math:`K_{0}`, :math:`K_{1}`, :math:`K_{2}`, и т.д.
В обоих случаях, выбор остается за приложением, в котором применяется функция TLSTREE.

Реализован алгоритм выработки производного ключа при помощи
следующих функций библиотеки:

- `int ak_skey_derive_tlstree( ) <api/ak__kdf_8c.html>`__,
- `int ak_skey_derive_tlstree_from_skey( ) <api/ak__kdf_8c.html>`__,
- `ak_pointer ak_skey_new_derive_tlstree_from_skey( ) <api/ak__kdf_8c.html>`__.

Согласно рекомендациям Р 2323565.030-2019 условие

.. math::

   K_{n} = \texttt{TLSTREE}( MK, n ) \not= \texttt{TLSTREE}( MK, m ) = K_{m}, \quad n \not= m

в общем случае, `не обеспечивается`. Выполнение этого условия зависит от используемого
множества предопределенных в Р 2323565.030-2019 констант. При этом, само множество констант является
обязательным параметром алгоритма TLSTREE и передается в функцию при помощи переменной типа `tlstree_t`.

Библиотекой гарантируется уникальность вырабатываемых производных ключей,
только для значений `tlstree_with_libakrypt_65536` и `tlstree_with_libakrypt_4096`.
В остальных случаях, поведение функции соотвествует Р 2323565.030-2019.

Простейший пример
использования функции `ak_sket_derive_tlstree()` приводится ниже (файл ``example-g05n01.c``).

.. literalinclude:: ../examples/faq/example-g05n01.c
 :language: c
 :linenos:

Пример, в котором последовательно вычисляются производные ключи
:math:`K_{0}`, :math:`K_{1}`, :math:`\ldots`, :math:`K_{15}`, приводится далее в файле ``example-g05n02.c``.
Здесь иллюстрируется вызов функции `ak_skey_new_derive_tlstree_from_skey()`,
позволяющей выработать контекст секретного ключа, что называется, `готовый к применению`
-- в данном примере, готовый к зашифрованию и расшифрованию данных с помощью блочного шифра "Магма"
в режиме гаммирования.

.. literalinclude:: ../examples/faq/example-g05n02.c
 :language: c
 :linenos:


Для оптимизации
последовательной генерации ключей с использованием алгоритма TLSTREE
может использоваться специальный контекст и набор функций:

- `int ak_tlstree_state_create( ) <api/ak__kdf_8c.html>`__,
- `int ak_tlstree_state_next( ) <api/ak__kdf_8c.html>`__,
- `ak_uint8 *ak_tlstree_state_get_key( ) <api/ak__kdf_8c.html>`__,
- `int ak_tlstree_state_destroy( ) <api/ak__kdf_8c.html>`__.

Пример использования данных функций приводится ниже (файл ``example-g05n03.c``).

.. literalinclude:: ../examples/faq/example-g05n03.c
 :language: c
 :linenos:


Класс преобразований из Р 1323565.1.022-2018 и последовательности производных ключей
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В предыдущем случае необходимо помнить MK
на протяжении всего срока дейcтвия ключевой информации, который (срок) может быть весьма большим.
Потенциально, это создает возможность компрометации значения некриптографическими способами.

Для защиты от такой угрозы реализован подход,
в котором предыдущее значение уничтожается после создания следующего и тем самым сокращается срок
хранения актуальной ключевой информации.



..
   Хеширование и вычисление имитовставок
   =====================================

   Аутентифицированное шифрование (AEAD)
   =====================================

   Простая реализация
   ~~~~~~~~~~~~~~~~~~

   Прямое  и обратное преобразования,
   которые могут быть получены через `oid->func.direct( .. )`

