Служебные и вспомогательные функции библиотеки
==============================================

В этом разделе рассматриваются служебные
и вспомогательные функции, которые входят в состав библиотеки ``libakrypt-base``.
Большинство этих функций носят служебный характер и реализованы для исключения внешних зависимостей.

Что такое аудит и как им пользоваться?
--------------------------------------

Аудит -- это вывод сообщений об ошибках и штатных действиях программы.
К аудиту, в частности, относится вывод информации о
вводе и смене ключей, изменении прав доступа, результаты об удаленной аутентификации пользователей и т.п.

Все сообщения библиотеки могут быть разделены на три уровня:

- первый уровень аудита определяется константой ``ak_log_none``, на этом уровне выводятся
  только сообщения об ошибках;
- второй уровень аудита определяется константой ``ak_log_standard``, на этом уровне
  выводятся сообщения об ошибках, а также сообщения, регламентируемые действующей нормативной базой,
  см. рекомендации Р 1323565.1.012-2017;
- третий (максимальный) уровень аудита определяется константой ``ak_log_maximum``,
  на этом уровне выводятся все сообщения, доступные на первых двух уровнях, а также
  сообщения отладочного характера, позволяющие проследить логику работы функций библиотеки.

Пользователь может настраивать уровень аудита,
определять собственную функцию вывода сообщений, а также выводить собственные сообщения.

В следущем примере пользователем устанавливается максимальный уровень аудита и
определяется собственная функция для вывода сообщений (файл ``example-g01n02.c``).

.. literalinclude:: ../examples/faq/example-g01n02.c
 :language: c
 :linenos:

В случае, когда аргумент функции :func:`ak_libakrypt_create` принимает значение ``NULL``,
то используется функция аудита, установленная по-умолчанию.
Для этого в библиотеке реализованы две стандартные функции:

- функция :func:`ak_function_log_stderr` реализует вывод в стандартный поток вывода ошибок
  и используется по-умолчанию в ОС `Windows`,
- функция :func:`ak_function_log_syslog` реализует вывод и использованием демона
  `syslog <https://en.wikipedia.org/wiki/Syslog>`__ и используется по-умолчанию в Unix-системах.


Пользователь может выводить собственные сообщения, используя механизмы библиотеки `libakrypt`.
Для вывода сообщений необходимо использовать функции :func:`ak_error_message`
или :func:`ak_error_message_fmt`, которые формируют строку с сообщением специального вида и
выводят данную строку с использованием установленной выше функции.

Пример такого вывода
иллюстрируется следующим образом (файл ``example-g01n03.c``).

.. literalinclude:: ../examples/faq/example-g01n03.c
 :language: c
 :linenos:



Есть ли функции для преобразования двоичных данных?
---------------------------------------------------

При тестировании и отладке криптографических алгоритмов возникает необходимость выводить
обрабатываемые данные в человекочитаемом виде, т.е. в виде последовательности шестнадцатеричных символов.
Наиболее употребимым способом вывода областей (дампов) памяти
произвольного размера является использование следующих функций:

- функция :func:`ak_ptr_to_hexstr` предназначена для преобразования произвольной области памяти
  в строку шестнадцатеричных символов (функция возвращает указатель на стек, данные в котором могут быть
  перезаписаны при следующем вызове функции библиотеки);
- функция :func:`ak_ptr_to_hexstr_alloc` предназначена для преобразования произвольной области памяти
  в строку шестнадцатеричных символов (функция возвращает указатель на область в оперативной памяти,
  которая позднее должна быть удалена пользователем с помощью функции :func:`free`);
- функция :func:`ak_hexstr_to_ptr` предназначена для обратного преобразования строк
  шестнадцатеричных символов в двоичные данные;
- функция :func:`ak_hexstr_size` высчитывает максимальную длину в
  байтах для формируемой последовательности двоичных данных.


Простейший пример использования указанных функций приводится ниже (файл ``example-g02n01.c``).

.. literalinclude:: ../examples/faq/example-g02n01.c
 :language: c
 :linenos:

Какие ещё есть функции для работы с двоичными данными?
------------------------------------------------------

Дополнительно, в библиотеке реализован ряд вспомогательных функций для работы с областями памяти.

- функция :func:`ak_ptr_is_equal` выполняет побайтное сравнение двух областей памяти,
- функция :func:`ak_ptr_is_equal_with_log` выполняет побайтное сравнение двух областей памяти;
  в случае выявления различия данных, с помощью системы аудита выводится не только сообщение об ошибке,
  но и место, в котором находится различие;
- функция :func:`ak_ptr_fletcher32` вычисляет контрольную сумму Флетчера;
- функция :func:`ak_ptr_load_from_file` позволяет считать указанный файл в буффер
  (если выделенной под буффер памяти не достаточно, то функция выделяет область в оперативной памяти,
  данная область должна быть позднее освобождена с помощью функции :func:`free`).


Можно ли кодировать данные в base64?
------------------------------------

Основная причина использования кодировки **base64**
заключается в необходимости создания сертификатов открытых ключей в формате `pem`,
контейнеров секретных ключей, а также почтовых вложений, кодируемых при помощи алфавита
из 64-х символов:

.. code-block:: c

  /*! Используемый для кодирования алфавит, согласно RFC1113 */
  static const char base64[]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

В случае необходимости использования кодировки **base64**,
библитека предоставляет следующие функции:

- функция :func:`ak_ptr_to_base64` выполняет кодирование двоичных данных в строку символов,
- функция :func:`ak_ptr_to_base64_alloc` выполняет кодирование двоичных данных в строку символов, с обязательным
  выделение оперативной памяти под строку символов,
- функция :func:`ak_ptr_to_base64_size` вычисляет объем памяти, в которую может поместиться закодированная строка,
- функция :func:`ak_base64_to_ptr` выполняет обратное преобразование и преобразует строку символов
  в двоичную последовательность.

Пример использования указанных функций содержится в файле ``example-g02n04.c``.

.. literalinclude:: ../examples/faq/example-g02n04.c
 :language: c
 :linenos:



Есть ли функции для работы со списками?
---------------------------------------

В библиотеке реализован интерфейс для работы с двусвязными списками.
Элемент списка определяется следующей структурой.

.. code-block:: c

 /*! \brief Узел двусвязного списка. */
 typedef struct list_node {
   /*! \brief указатель на хранимые данные. */
    ak_pointer data;
   /*! \brief указатель на предыдущий узел списка. */
    ak_list_node prev;
   /*! \brief указатель на следующий узел списка. */
    ak_list_node next;
 } *ak_list_node;


Структура содержит в себе указатель ``data``, который должен использоваться
для размещения произвольных данных.
Создание узла двусвязного списа возлагается на пользователя.
Если в качестве данных выступает строка символов,
то можеь быть использована функция :func:`ak_list_node_new_string`.

Пример использования двусвязного списка приводится ниже (файл ``example-g02n02.c``)

.. literalinclude:: ../examples/faq/example-g02n02.c
 :language: c
 :linenos:

Если вам необходимо работать с двусвязными списками строк,
то для этого библиотека реализует еще одну функцию :func:`ak_list_node_new_string`.
Пример ее использования приводится далее (файл ``example-g02n03.c``).

.. literalinclude:: ../examples/faq/example-g02n03.c
 :language: c
 :linenos:


..
   Существуют ли функции для работы с файлами конфигурации?
   --------------------------------------------------------
   Как кодировать в base64?
   ------------------------------------------------------------
   Как организовать доступ к файлам?
   ------------------------------------------------------------
   Есть ли интерфейс к разделяемой памяти?
   ------------------------------------------------------------


